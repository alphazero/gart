-- Friend

== 2.0 ==

simplified, minimal, repo structure:

.gart/
	tags/
		systemics.dat -- maybe
		tagdict.dat
	index/
		objects.idx
		cards/
			00/
			..
			ff/
		tagmaps/
			00/
			..
			ff/

-- why tags/ and index? 

tags are inherently independent of the index. The index relies on tags. 

Also tag manangement can be a fairly substantial sub-system. From basic typo-correction, 
command-line tag completion, to tag inference from content & similarity to other objects.


== 1.0 ==

We maintain a DOC file for each tracked 'content'.
A DOC file may point to 1 or more copies of the same content. (DUPS)
Paths can get quite large and are mostly redundant. There are a lot of common root path fragments.

So we maintain a shadow FS structure.
- break path into components
- sha each component and take 2 bytes. e.g. Applications/ -> 0x2fbe
- create the path tree using the 2 byte value (assuming highly unlikely that in a given dir two child dirs will collide. (They could collide system wide but we dont care)
- for each copy of the content, in its card file, we encode the path using the 2b values, so a path that is say 200 chars and is 10 levels deep can be encoded as 2x10=2B.

.gart/
	locks/
		? to start lets keep it simple and assume no concurrent archiving.
	tags/
		TAGSDEF
	paths/
		device-id/
			volume/
				HD/
					2fbe/
						NAME -- this file has content "Applications". 
						98ce/
							DIR -- this file has content "Keynote.App"
							... etc.
				OpenGate/
				USB/
				..
	index/
		TAGS  -- this is the bah bitmaps of all content
		cards/
			ec/
				9d83df... -- this file is the 'CARD' file for the content
							 it has list of all full-path file names for this content
							 it also has offset into TAGS
							 	* issue is path encoding is VAR len and is binary to save space.
								? accept 2x cost and encode as binhex and use /n (0x13) to delim?
								! use binehx/n on the first line and provide lens|offsets for each path encoding

								tags:64bit-hex. 0:len 1:len [other-metadata]\n
                                <path encoding of len 0:len>
								<path encidnng of len 1:len>
								...

								CARD EXAMPLE 
									- tag map is in TAGS at offset 1011252 (0x000000000000f6e34)
									- content is DUP and have 4 copies
									4 varlen path encodings follow

								tags:000000000000f6e34 0f 0c 09 10\n
                                <0x0f bytes>
								<0x0c bytes>
								<0x09 bytes>
								<0x09 bytes>

					* that offset is taking 32 bytes! 
					  assuming average bitmap is 32 bytes, 1MM bitmaps is still 32bit
					! UNUM encode the offset and then hexbin that.

	UPDATE: concerns
	1 - size
		possibly won't be a concern. but obviously all dirs in the archive's items
		shadow the corresponding fs hierarchy. Non issue?

	2 - (To test) how fast is it to walk the fs tree?
		
	3 - (To test) why not just gzip the paths in the CARD?
		this doesn't address the (likely heavy) redundant storage of path prefixes.
		most of my stuff, for ex, is in a handful of document paths


	IDEA!

		use sym-links to originals in the cards folder:
			ae/
				00/
				40/
					5fe39480a248dc8f.card -- card file - note actual has has ae prefix
					5fe39480a248dc8f.0 -> -- sym link to the first source /Users/alphazero/.../foo.pdf
					5fe39480a248dc8f.1 -> -- sym link to the 2nd  source
					etc.

		test os.ReadLink(..).
	ISSUE: how to create sym links in Go. (worst case it is a syscall).
				80/
				c0/
On archive-add <file> --tags "a,b-c,d e,x" 

	-- assume this is first time so not redundant

	1 - paths is updated. 
		minimally, we need to add the filename 
		maximally, we need to add the path hierarchy and then the file name
	2 - since all files will have 1 or more system level 'tags' (e.g. '.PDF')
		and we don't have a CARD file, we then add the tags bitmap to TAGS file.
		So seek-end, get offset, and append the var-rec entry.

		* if user tags are provided on ADD (or archive-tag <file>) 
          we need to read or update the TAGSDEF file.
		  we need to then get the tag-id for each tag to construct the tag bitmap.

	3 - finally, create the CARD for the file. (see above)

On find --tags "pdf, distributed systems, consensus" 

	1 - read TAGSDEF to get the set of tag-ids
	2 - sort them
	3 - scan index/TAGS and for each 
