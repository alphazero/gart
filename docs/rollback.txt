-- Doost!

Rollback -- as of now effectively only via interrupted gart ops -- is (obiously)
directly related to the index structure(s). 

Current design:

	[ card : key ] 	-> 	[ oidx ]  # not really used
	[ oidx : oid ] 	-> 	[ card ]  # used on tag based searches
	[ tag_x : bit ]	-> (as key) -> [ oidx ]

	card files are swapped in whole on update.
*	oidx is append only with in-place header mods. It is -not- swapped. 
	tag files are swapped in whole on update.

Side-effecting ops proceed as follows:

	- card is loaded, modified, and swapped.
	- oidx is updated until closed.
	- tagmap(x) is loaded, modified, and swapped.

An indexManager 'session' is a (broken) transaction scope. It is broken given
that it only maintains the oidx and tagmaps in memory, and on close it writes
the oidx and tagmaps back. (*oidx is in fact only closed. it is already modified
in that the new records have been appended, but the header is only 'encoded' to
the memory mapped array on close, so if index manager does not close cleanly, the
header is effectively stale and object.idx file is corrupted.)

There is a certain logic to not holding the card files in memory -- the number
of cards (say in a find . | gart add pattern) can be fairly large.

Only the tagmaps are correctly handled at this point.

	- cards are updated immediately.
		- prior state is unrecoverable 
			solution: load card, save to temp file and swap on close.

	- object.idx records are updated immediately
		- prior state (as of append only ops of now) is recoverable
			solution: treat object.idx like cards and tagmaps. 


-- other issues with the index design --

More fundamentally, object.idx grows and grows. index does support 'delete' op,
but this collects garbage. In fact, we simply mark the associated card with a
deleted flag. 

	- a 'compact' process can 'rebuild' the index, but this basically means
	that it will have to rebuild the entire index from the card files. it is
	doable but it will be slow:

		- open index
		- create new (temp) object.oidx.new
		- set counter 'key' to 0
		- delete all tagmaps
		- read object file sequentially
		- for each record in object.idx
			- oidx.oid -> card file
			- load tagmaps (create:true) for card's tags
			- if card.isDeleted 
				- delete card
		 	  else
				- append record to object.oidx.new
				- for each tag in card
					- set key bit in tagmap
				- increment 'key'
				- reset key for card file
		  end loop

-- initial TODO steps 

	- all index files must follow pattern:
		- load from canonical 'filename'
		- write to '.filename.swp'
		- swap on commit


